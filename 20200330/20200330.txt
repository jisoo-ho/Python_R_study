　#빅데이터
　1. 데이터
1) 정성적 데이터 : 언어, 문자 등으로 이루어짐 – 오늘 날씨가 좋다 
2) 정량적 데이터 : 수치, 도형, 기호 등으로 이루어짐 – 나이, 몸무게
3) 목적론적 특성 : 우리의 인식체계에서 어떤 사실에 대해 “데이터”라고 인식하게 되는 객체가 가지고 있는 존재 목적.
수요조사, 실험 검사 측정 등을 통해 데이터를 수집 축적 다양한 방법으로 분석 하여 논문 예측 경영전략 정책을 수립하는 일련의 가치 창출.
　- 총선에 관련된 것 또한 수요조사 중 하나(코로나로 인한 마스크 구매 - 중국에서 원료 조달 불가로 인해 생산 차질 발생)

4) NoSQL : Not-Only-SQL 빅데이터 분산처리 및 저장 기술과 함께 발달된 분산 데이터베이스 기술(정형화 되지 않은 SQL)
　- 구조적인 쿼리문이 아니다.(Map의 특징 : 키와 밸류로 존재)
　- NoSQL 기본개념 : Key-Value : 가장 기초적이며 다른 데이터 모델의 기본이 됨. Dynamo, Redis
　- ★(면접)JSON : 자바스크립트의 오브젝트 타입으로 만들어진 문서(키:밸류 형태)
　- MariaDB - MySQL, MongoDB의 장점을 통해 만들어진 DB 프로그램

5) 빅데이터의 3요소 : Variety, Velocity, Volume : 클 가능성을 가진 모든 디지털 형태의 데이터

　2. 빅데이터의 활용
1) 시장 예측 : 앙상블 기법(주 알고리즘) - 내일 주가예측 등을 할 수 있다.
2) 선호도 분석 : 라이브러리를 이용해 원하는 차트 제작 가능
3) 사회적 분위기 파악 : 사회적 현상을 파악해서 사업 방향성 고려(가정식 음식 개발에 집중 투자)
4) 트렌드 감지 및 예측 
5) 빅데이터가 변화시킨 것들
　- 사전처리 --> 사후처리(표준화된 문서포맷)
　- 표본조사 --> 전수조사(잉여력)
　- 질 --> 양(번역시스템)
　- 인과관계 -->상관관계(Aviva)
6) Goofle flu Trends

7) 국내사례(SKT)
　- 기업의 평판을 실시간으로 모니터링하여 기업의 대응전략 마련
　- 국내 기업의 한계점
　 --> 데이터, 텍스트 마이닝을 하는 것 보다 모니터링에 그침
　 --> 한국의 형태소 근원에 대한 명확한 텍스트 마이닝 기술 어려움
　 --> SNS의 활동 등이 facebook, twitter 가 크지 않음

8) 빅데이터 활용 분석 기본 테크닉
　1) 연관규칙학습(Association Rule Learning) - CCTV 영상분석을 통한 동선 분석 및 상품 배치에 사용
　--> 상품 혹은 서비스간의 관계를 살펴보고 이로부터 유용한 규칙을 찾아내고자 할 때 이용될 수 있는 기법. 
　연관성측정(Associations)은 어떤 특정 문제에 대해 아직은 일어나지 않은 답(예를 들어, 부도 · 건전)을 
　얻고자 하는 예측(Prediction)의 문제나 고객들을 특정목적에 따라 분류(Segmentation)하는 문제가 아니라, 
　상품 혹은 서비스(이하 상품)의 거래기록(Historical)데이터로부터 상품간의 연관성 정도를 측정하여 관성이 많은 
　상품들을 그룹화하는 클러스터링(clustering)의 일종.

　2) 유전 알고리즘(Genetic Algorithms) - 병리학, DNA, RNA, 환경, 생태계 등에 사용(주로 적자생존 이론을 기본 개념으로 한다)
　--> 유전 알고리즘은 자연계의 생물 유전학에 기본 이론을 두며, 병렬적이고 
　전역적인 탐색 알고리즘으로서, 다윈의 적자생존 이론을 기본 개념으로 한다. 유전 알고리즘은
　풀고자 하는 문제에 대한 가능한 해들을 정해진 형태의 자료구조로 표현한 다음, 이들을 점차적으로
　변형함으로써 점점 더 좋은 해들을 만들어 낸다. 여기에서 해들을 나타내는 자료구조는 유전자,
　이들을 변형함으로써 점점 더 좋은 해를 만들어 내는 과정은 진화로 표현할 수 있다.

　3) 회귀분석(Regression Analysis)
　: 변수들 간의 상호 관련성을 규명하고 어떤 변수들의 변화로부터 다른 변수들의 변화를 예측하는 기법
　　--) 상관분석 ( 반드시 상관계수값이 필요 ) ( 연관성 )
　두 변수의 역할이 서로 대등할 때 사용. ex)키와 몸무게
　목적(target)변수의 역할이 서로 바뀔 수  있을 때 역할의 구분이 없을 때
　두 변수간의 직선적(linear) 관련성의 강도(strength)를 하나의 값, 상관계수(correlation coefficient)
　　--) 회귀분석 ( 반드시 회귀 계수가 필요 ) ( 방향성 )
　두 변수의 관계에 분명한 방향(direction)이 있을 때 ex)혈압과 체질량 지수
　반응변수와 설명변수(종속변수와 독립변수)  회귀계수(Regression coefficients)

　4) 유형분석(Classification Tree Analysis) ( 집단에 관련된 분석 )
　--> 이 사용자는 어떤 특성을 가진 집단에 속하는가? 와 같은 문제를 해결하고자 할 때 사용한다.
　통계적 분류는 새로운 사건이 속하게 될 범주를 찾아내는 일이다. 이를 위해서는 기존 자료를
　바탕으로 만들어진 Training Set이 있어야 한다. 이 기법은 문서를 분류하거나 조직을 그룹으로 나눌 때,
　혹은 온라인으로 지원한 수강생들을 특성에 따라 분류할 때 사용할 수 있다.

　5) 기계학습(Machine Learning) ( 지도학습에서 강화학습 까지, AI의 기초단계 - 반드시 훈련 데이터(맞다or틀리다) 필요 )
　--> 기계학습은 기존의 시청 기록을 바탕으로 시청자가 현재 보유한 영화 중에서 
　어떤 것을 가장 보고 싶어할까? 와 같은 문제를 해결할 때 사용된다. 이를 위해 기계학습은 
　데이터를 통해 학습할 수 있는 소프트웨어를 포함하고 있다. 기계학습은 훈련 데이터로부터 
　학습한 알려진 특성을 활용해 예측하는 일에 초점을 맞춘다.

　6) 소셜네트워크 분석(Social Network Analysis) ( 인플루언서, 국가간의 거래(통화스와프) 등 담당자의 성향 )
　--> 사회관계망 분석이라 불리는 소셜네트워크분석은 특정인과 다른 사람이 몇 촌 정도 인가?
　를 파악할 때 사용한다. 이를 통해 오피니언 리더, 즉 영향력 있는 사람을 찾아낼 수 있으며, 
　고객들 간의 소셜 관계를 파악할 수 있다.

　7) 감정분석(Sentiment Analysis) ( 기생충의 번역이 좋아서 흥행 )
　--> 특정 주제에 관하여 말하거나 글을 쓴 사람의 감정을 분석한다. 

9) 빅데이터 분석기법
　1) 통계적 기법과 차이점
　- 가설 확인 중심의 통계적 방식 ( 기존 가설을 정해놓고 맞춰가는 방식, 공약을 걸고 공약에 맞는 합리성 찾기 )
　- 빅데이터 : 가설 발견 중심의 데이터 마이닝 방식 ( 정답이 만들어질 수 없는 방식 - 이렇게 하면 잘 될거라는 미래예측 방식 )
　 --> 사회적 데이터를 모아서 가설을 찾아가는 방식

　2) 결론 : 데이터 분석은 결국 앞서 소개한 기법으로 데이터를 분석해 '흥미로운 상관관계를 
　발견하거나', 사용자를 특정한 유형으로 분류하고, 보유한 자원을 적당하게 할당하거나, 
　서비스나 상품의 가치를 책정하는데 도움을 받을 수 있다. 나아가 여러기법을 결합해 다양한 
　비즈니스 모델을 개발할 수 있다. '데이터뿐 아니라 분석 테크닉까지 창의적으로 재 조합해 활용하면, 
　기존에 없던 비즈니스 모델 개발이 가능할 수도 있고 새로운 가치도 창출할 수 있게 된다'. 

https://www.r-project.org/ : 오리지널 사이트 주소
 - 버전에 따라 라이브러리도 달라진다.



----------------------------------------------------------------------------------------------------
　# R
1. (전반적인 코드를 만드는 것 보다는)구문보다는 데이터 기반 문제를 해결의 '절차 위주'(절차 지향)로 생각하고 
　그에 맞는 라이브러리를 잘 활용하는 방법을 공부해야 할 때! 사용한다. (라이브러리별 활용법 정리 필수)
　- 데이터프레임 자료구조가 가장 중요. ( R은 통계 위주방식이므로 통계청 등의 문서를 DF로 읽어올 수 있다.)
　- 1차원 배열 형태 : 벡터, 2차원 배열 : 배열, 다차원 배열 : 리스트 라고 부른다.
　- 벡터나 리스트를 알아야 하는 경우
　--> 부동산 중 가장 이슈로 많이 들어오는 것 : 아파트(시세, 공시지가), 아파트 시세를 결정하는 요인이 무엇인지 분석
　1) 아파트가 비싼지역(변수) 
　　-> 사회적 관점 : 실 수요자 연령, 범죄율-검거율, CCTV 대수, 소득수준(현금성자본), 학원 등
　　　1-1) 60대가 신경쓸 점 : 편의시설, 가격방어, 대중교통, 뷰
　　　1-2) 40~50대 신경 쓸 점 : 학군, 직장거리, 구성원, 편의시설, 대중교통
　　　1-3) 20~30대 신경 쓸 점 : 상권, 리모델링, 직장거리, 뷰, 대중교통, 편의시설

　2) 다양한 사이트에 퍼져있는 데이터를 가지고 와서 뽑아서 데이터프레임으로 묶어줘야 한다.
　　--> DF로 만들어야 분석이 가능(DF로 다룰려면 벡터, 배열, 리스트를 완전히 알고 있어야 한다.)

　3) 패키지 부분 : 추가적인 패키지는 (★면접)CRAN(미러사이트)을 통해 다운

　4) 기타 패키지 설치 방법(패키지 설치 함수) : install.packages("패키지명"), library(패키지명) (임포트 하듯 가져오는게 라이브러리 함수)
　 -> 패키지와 라이브러리 차이 
　　: 패키지는 R 함수들을 모아 놓은 컬렉션이며, 라이브러리(library)는 R 패키지가 저장되는 폴더를 의미

　5) R 없이 R-Studio는 절대 사용 불가(R console 은 한줄 쓰고 바로 엔터치면 바로 실행되는 인터프리터
　-> 여러 줄을 써서 실행시키려면? : (처음 일단 먼저 저장부터 하고 시작) 파일 > 새 스크립트
　※ R 저장시, 작업공간 이미지 저장을 같이 하면 기존 변수에 데이터가 들어간 상태로 유지가 된다.(Y/N)

　6) 명령어
　 - library(help = "base") : 기본 패키지 목록 출력(기본적으로 설치된 패키지 리스트)
　 - install.packages("plotrix") -> CRAN 미러 선택(Korea - Seoul 선택 후 확인) 
　　- 실제 설치된 패키지 위치 :　C:\Users\USER\AppData\Local\Temp\RtmpUBw8DQ\downloaded_packages
　　　(오류가 났을 때, 여기 폴더에서 삭제해버리고 다시 설치하는게 가장 깔끔하다)


### 기본적으로 base 패키지에 들어있는 함수
2. 벡터 만들어주는 함수 : c (combine 함수)
　- ex ) x <- c(80, 85, 70) 
　- c(80, 85, 70) -> x
　- x <- c(80)

　1) R 산술 연산자
　- 더하기 : +
　- 빼기 : -
　- 곱하기 : *
　- 나누기 : /
　- 거듭제곱 ^ 또는 **
　- 나머지 : %%
　- 몫 : %/%

　2) 논리연산자 - 진위여부 : isTRUE(x) : x <- TRUE, isTRUE(x) 하면 결과값이 TRUE로 나온다.
　-. 논리 부정 : x<- 3 일 때, !x를 하면, FALSE ( 숫자의 경우 0이면 FALSE, 그 외는 TRUE로 인식됨) - R은 변수에 데이터 타입이 없어서 0이 아니면 모두 TRUE

　3) 어떤 벡터를 만드는데 1씩 증가하는 벡터를 만들고 싶을 때
　- x <- seq(1,10, by=3) ( 1부터 3씩 증가하는 10 이하의 정수, 시작값과 끝 값을 만들어 준다. )
　- y <- seq(1,10, length.out=5) ( 1~10 사이를 같은 간격으로 하는 5개의 숫자 )
　- by 옵션, to 옵션, from 옵션 ( 일련번호의 증가, 일련번호의 종료 값, 일련번호의 시작 값 )

　4) 벡터 반복 함수
　- x<- c(1,2,3)
　- rep(x, times=2) x 벡터를 2번 반복( 1 2 3 1 2 3 )
　- rep(x, each=2) x 벡터의 각 원소를 2번 반복(1 1 2 2 3 3 )
　->결과값도 특정 변수에 할당 가능

　5) 벡터를 구성하는 특정 원소 값들을 출력하거나, 수정하는 과정
　- x <- c(1, 2, 3, 4, 5)

　- x[2] # 두 번째 원소
　- x[c(1, 3, 5)]  # 1, 3, 5번째 원소
　- x[-c(2, 4)]  # 2, 4번째 제외한 원소

　- x[x＞2]  # 원소의 값이 2보다 큰 값들만 출력
　- x[x＞=2 & x＜=4] # 원소의 값이 2 이상이고 4 이하인 값들만 출력

　- x[2] <- 20  # 2번째 원소의 값을 20으로 수정
　- x[c(3, 4)] <- 15   # 3, 4번째 원소들의 값을 모두 15로 수정
　- x[x＜=15] <- 10  # 15 이하인 원소 값들을 모두 10으로 수정

　6) x <- seq(1:10) 
　- mean(x) # x벡터의 원소 값들의 평균
　- var(x) # x 벡터의 원소 값들의 분산
　- sd(x) # x 벡터의 원소 값들의 표준편차
　- sqrt(x) # x 벡터의 원소 값들의 제곱근
　- length(x) # x 벡터의 원소 값들의 개수
　- abs(x) # x 벡터의 원소 값들의 절대값

3. 배열
　1) 원소가 홀수로 있을 경우와 짝수로 있을 경우의 중앙값이 다르다.
　- 짝수개인 경우 가운데 값의 2개를 더한 후 2로 나눈 값
　- 배열: 한 개 이상의 벡터로 구성, 동일한 데이터 유형
　- 1차원 배열: 벡터
　- 2차원 배열: 행과 열, 행렬 
　- 함수: array()
　 --> 벡터는 배열을 포함할 수 [없다]. 배열은 벡터를 포함할 수 [있다].

　2) base 패키지 내부의 함수 array
　 x<-array(1:3, dim=c(3)) : 1~3까지의 정수를 1행 [3열]의 1차원으로 표시( x<- seq(1:3)과 동일, 타입은 다르다(배열타입으로 반환))
　- data : 벡터 자료, dim : 차원을 나타내는 벡터, dimnames : 각 차원의 이름을 나타내는 벡터

　3) R 의 특성 : 1행 1열 부터 시작[1,1] (★ 0행 0열부터 시작이 아님)
　-  x<-array(1:6, dim=c(2,3)) : 1~6 까지의 정수를 [2행 3열]의 2차원으로 표시(★열 단위의 순서로 데이터를 할당)
　- x[1, 3]  # 1행 3열 값
　- x[, 3] # 3열의 모든 값들
　- x[, -3] # 3열을 제외한 모든 열의 값들
　- x[1, 2] ＜－ 20 # 1행 2열의 값을 20으로 수정(앞번호생략 가능)
　- x[-2,] # 2행을 제외하고 출력
　- names ＜－　　　# 행과 열 이름을 갖는 두 벡터로 하는 리스트 생성
　-　　list(c("1행", "2행"), 
　-　　　c("1열", "2열", "3열"))

　4) matrix() 함수 : 행과 열을 만들어주는 전용 함수
　　: x<-matrix(1:6, nrow=2)  # 1~6사이의 정수를 행의 수가 2인 행렬로 만듦, 원소값의 할당 순서는 열 기준임
　　: byrow : data를 행 단위로 배치할지에 대한 여부. 디폴트는 FALSE 이며 열 단위로 배치
　　: ncol : 열 요소의 개수
　　: dimnames : 행과 열의 이름 list

　5) 벡터의 결합에 의한 행렬
　　: v1 <- c(1,2,3,4)
　　: v2 <- c(5,6,7,8)
　　: v3 <- c(9,10,11,12)
　　--> x<-cbind(v1,v2,v3) # 벡터 v1,v2,v3을 열 단위로 합침(cbind는 column bind를 의미)
　　출력 결과 : 열을기준으로 오른쪽으로 붙여나간다.
　　rbind(v1,v2,v3) 행을 기준으로 붙여나간다.
rownames(x) ＜－ c("1행", "2행", "3행", "4행") # x 행렬에 행의 이름 추가
colnames(x) ＜－ c("1열", "2열", "3열") # x 행렬에 열의 이름 추가
　-> 행렬 이름들은 컴바인 함수로 할당해줘야 한다.

　6) 리스트
　- 벡터의 각 원소 : 이름, 서로 다른 데이터 유형 가능, 하나 이상의 값 가능
　- 함수 : list()
　- x<- list("홍길동", "2016001", 20, c("IT융합", "데이터관리"))

[[1]]
[1] "홍길동"

[[2]]
[1] "2016001"

[[3]]
[1] 20

[[4]]
[1] "IT융합"　　"데이터관리"

　- y <- list("성명"="홍길동", "학번" ="2016001", "나이" = 20, "수강과목" =c("IT융합", "데이터 관리"))

$성명
[1] "홍길동"

$학번
[1] "2016001"

$나이
[1] 20

$수강과목
[1] "IT융합"　　"데이터 관리"

　7) 데이터프레임
　- x <- data.frame(성명=c("홍길동", "손오공"), 나이=c(20,30), 주소=c("서울", "부산"))
　　성명 나이 주소
1 홍길동　20 서울
2 손오공　30 부산

　--> row.names : 이 함수를 이용해서 열의 이름 변경 가능

x <- cbind(x, 학과=c("전산학", "경영학")) : 데이터 프레임 x에 열(학과) 추가
x <- rbind(x, data.frame(성명="장발장", 나이=40, 주소="파리", 학과="전산학")) : 데이터 프레임 x 에 행(장발장) 추가 

　　성명 나이 주소 　학과
1 홍길동　　20 서울 전산학
2 손오공　　30 부산 경영학
3 장발장　　40 파리 전산학

　　7-1) 값 뽑아내기
# 3행 2열의 요소 값
x[3, 2] 

# 3행의 모든 값
x[3, ]

# 2행을 제외한 모든 값
x[-2,]

# "성명" 요소
# x[1]과 동일한 결과
x["성명"]

# "성명" 요소값
x$성명 or x[["성명"]] or x[[1]]

> x$성명
[1] 홍길동 손오공 장발장
Levels: 손오공 홍길동 장발장

> x[["성명"]]
[1] 홍길동 손오공 장발장
Levels: 손오공 홍길동 장발장

> x[[1]]
[1] 홍길동 손오공 장발장
Levels: 손오공 홍길동 장발장

# 1열 요소 값에서 두 번째 값
x[[1]][2]


　8) R에서 데이터 파일 읽기 : 자체적으로 읽는 방법, 외부에 있는 데이터를 읽는 방법
　9) 데이터 셋 다루기
head(quakes, n=10) # 데이터의 앞부분 10개 행 보기(디폴트 n은 6)
tail(quakes, n=6) # 데이터의 뒷부분 일부 보기(디폴트 n은 6) : 원하는 데이터가 끝까지 들어왔는지 확인
　--> lat, long ( 위도, 경도 ) depth( 고도 ), mag ( 지진 강도 )

names(quakes) # ‘quakes’ 데이터 세트의 변수명 보기
str(quakes) # ‘quakes’ 데이터 세트의 데이터 구조 보기
dim(quakes) # ‘quakes’ 데이터 세트의 차원 보기(행과 열의 수) : (1000행, 5열)
summary(quakes) # ‘quakes’ 데이터 세트의 각 변수별 데이터 요약 정보
summary(quakes$mag) # ‘quakes’ 데이터 세트 내의 mag 변수에 대한 최솟값, 25백분위수, 중앙값, 평균값, 75백분위수, 최댓값


write.table(quakes, "D:/hojisoo/RPYTHON/20200330/quakes.txt", sep=",") : temp 폴더에 quakes.txt로 저장(데이터 간 구분자는 ','
(폴더가 존재하지 않으면 error)

x<-read.csv ("D:/hojisoo/RPYTHON/20200330/quakes.txt", header=T) : quakes.txt 읽기. header=T는 데이터 파일의 첫 번째 행을 항목 명으로 인식함.
x <- read.csv(file.choose(), header=T) : 읽어들일 파일을 선택할 수 있는 창이 나타남

　10) 바 차트
height <- c(9,15,20,6) : 판매액 할당 (이 데이터의 개수와)
name <- c("영업 1팀", "영업 2팀", "영업 3팀", "영업 4팀") : 막대 이름 설정 ( 이 데이터의 개수가 반드시 일치해야 한다.)
barplot(height, names.arg = name, main="부서별 영업 실적", col = rainbow(length(height)), xlab="부서", ylab="영업 실적(억원)") : 차트 생성
　- names.arg : x축에 어떤 데이터를 보여줄지 결정(arg 는 argument의 약자)
　- main : 차트에 대한 대표 타이틀
　- col : 차트를 뿌리는데 가장 기본적으로 색을 뿌려주는 함수가 rainbow 함수, 벡터의 개수를 알아내는 함수 lenght 사용. height가 가진 개수만큼만 색 사용하겠다.
　- xlab, ylab = x, y축 라벨명에 대한 이름 결정
##콘솔창에 ?함수명 (예시: ?barplot ) 치면 해당함수에 관한 엄청 자세한 내용이 브라우저로 보여짐

　11) 기본 파이 차트
x <- c(9,15,20,6) : 영업 실적 할당
label <- c("영업 1팀", "영업 2팀", "영업 3팀", "영업 4팀")
pie(x, labels=label, main="부서별 영업 실적")
## 기준은 3시방향, 반시계방향으로 나열 


4. 셋 디렉토리
# 아래와 같이 지정(반드시 해당 폴더가 만들어져 있어야 한다.)
setwd("c:\\r_temp")  : 역슬래쉬를 이용하려면 2번 써야 한다.

# 현재 설정된 작업 디렉토리 확인
getwd()

# 또는 아래와 같이 지정.
setwd("c:/r_temp")  : 슬래쉬를 쓰려면 한번만 사용
getwd()

 -> 작업하기 전에는 반드시 작업할 디렉토리를 지정하고, 작업 시(분석할) 필요한 데이터들을 저장

5. 출력 함수
　1) print() : 자바의 println() 함수
　- 문자를 출력할 때는 ' '을 사용 : 자바와 다른점은 ' '도 같이 출력된다.
　- 소수점일 경우 총 7자리로 출력 ( print(pi, digits=3) ) 을 하면 자리 수 지정 가능 (pi는 R의 내장 상수 값)
　- print() 함수는 한 번에 한 가지 데이터만 출력할 수 있다.
　- 문자를 print('b', 'a') 로 하게 되면 오류 발생

　2) cat() : 여러 개의 데이터를 출력하는 함수
　- cat(1, ':', 'a', '\n', 2, ':', 'b')
　　-> 1 : a, 2 : b 와 같이 출력 된다
　- 1;2;3 으로 실행하면 [1]1 [1]2 [1] 3 으로 실행된다.
　- 1+2 ; 2*3 ; 4/2 실행하면 [1] 3 [1] 6 [1] 2 결과 출력

6. R에게 줄 수 있는 자료들
　- 그 자료가 숫자인지 문자인지 날짜인지, 아니면 다른 특별한 형태인지를 알려주어야 한다. 
　- R에서 사용 가능한 자료(데이터)의 종류와 그 자료 형(데이터 형)은 정해져 있다. 

　1) 0이 5개 부터는 1e+05로 출력된다. (10000까지는 그대로 출력)
　- 1e2 는 100출력 ( 1 * 10^2 ) 라는 의미
　- 3e-1 은 소숫점 1자리로 출력하라는 뜻 : 0.3 출력 

　2) as.numeric() : 문자형 숫자를 연산 가능한 숫자로 변경하는 함수
　- as.numeric('1') + as.numeric('2') ===>>> [1] 3 출력

　3) 문자형
　- R에서는 단일 문자와 여러 문자로 구성된 문자열을 구분하지 않고, 전부 문자열 형태로 인식('' or "" 을 사용)
　- 'First' 문자라서 홑따옴표, 쌍따옴표로 감싸고 출력

　4) 문자형 데이터를 검사
　- class('1')  ===>>> [1] "character" 출력 (데이터 타입 출력)
　- class(1) ===>>> [1] "numeric" 출력 

　5) Boolean 값 자체가 전부 대문자(TRUE / FALSE)
　- 컴퓨터 : bit를 사용하여 동작되는 기기(0은 FALSE , 1은 TRUE)

　6) NA형 & NULL 형
　6-1) NA : 잘못된 값이 들어 올 경우 ( Not Applicable , Not Available, 결측값).
　 값이 있어도 정해진 범위 안에 있는 값이 아니라서 사용할 수 없는 경우. 
　 NA 값이 포함되어 있을 경우 연상르 수행하면 결과 값은 NA. 
　- is.na(변수명) : 변수의 값이 NA인지를 확인하는 함수.

　6-2) NULL : 값이 없을 경우. 값이 정해지지 않아서 얼마인지 모른다는 의미.

　ex) cat(1,NA,2) 를 입력하면 [1 NA 2] 로 출력이 된다
　cat(1,NULL,2) 를 입력하면 [1 2] 만 출력 된다.
　sum(1, NULL, 2) 를 입력하면 [3] 이 출력 된다.

　※R에서  NULL 값은 자동으로 제거하고 연산하지만, 
　NA값은 연산에 그대로 반영되기 때문에 값은 수동으로 제거해야한다.
　na.rm : NA 값을 수동으로 제거할 수 있는 파라미터. na.rm=T  (NA 값을 Remove) 

　ex) sum(1,2,NA) 하면 NA가 출력되지만 sum(1,2,NA,na.rm=T) 로 na를 제거하면 3이 출력 된다.

7. Factor 형
　- 여러 번 중복으로 나오는 데이터들을 각각 모아서 대표 값으로 출력해주는 데이터 형
　- c( ) : combine value 라는 의미로 여러 개의 값을 한꺼번에 처리할 때 사용되는 함수 
　> setwd("c:\\r_temp") : 워크 디렉토리 지정
　> txt1 <- read.csv("factor_test.txt") : txt1에 txt 파일 할당
　> txt1 : 할당된 txt1 데이터 호출 

　--> A, O, B, AB 형을 대표로 꺼낸 다음에 O형이 몇개의 데이터인지, A형이 몇개인지를 자동으로 만들어주는 것이 Factor 형

　> factor1 <- factor(txt1$blood) : factor 명이 txt1이 되어있는데 blood 열만 factor1에다 할당하겠다.
　> factor1
　[1] O  A  O  B  AB A  B  O  B  B 
　Levels: A AB B O

　> summary(factor1) : 연설문을 단어단위로 모두 쪼갰을 때 각 단어들이 몇 번 나오는지 확인 가능
　A AB B O 
　2  1  4  3 

　> sex_F <- factor(txt1$sex)
　> summary(sex_F)
　남 여 
　7  3 

8. 날짜와 시간
　- Sys.Date() : [1] "2020-03-30"
　- Sys.time() : [1] "2020-03-30 17:48:15 KST"
　- date()
　- as.Date('2020-03-30') [홑따옴표나 곁따옴표 사용]
　- 날짜 형태를 지정 : as.Date("30-03-2020",format="%d-%m-%Y") : [1] "2020-03-30"
